{"ast":null,"code":"'use strict';\n\n/**\n * @license Angular v14.2.0-next.0\n * (c) 2010-2022 Google LLC. https://angular.io/\n * License: MIT\n */\n(function (factory) {\n  typeof define === 'function' && define.amd ? define(factory) : factory();\n})(function () {\n  'use strict';\n\n  /**\n   * @license\n   * Copyright Google LLC All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n  /**\n   * A `TaskTrackingZoneSpec` allows one to track all outstanding Tasks.\n   *\n   * This is useful in tests. For example to see which tasks are preventing a test from completing\n   * or an automated way of releasing all of the event listeners at the end of the test.\n   */\n  var TaskTrackingZoneSpec = /** @class */function () {\n    function TaskTrackingZoneSpec() {\n      this.name = 'TaskTrackingZone';\n      this.microTasks = [];\n      this.macroTasks = [];\n      this.eventTasks = [];\n      this.properties = {\n        'TaskTrackingZone': this\n      };\n    }\n    TaskTrackingZoneSpec.get = function () {\n      return Zone.current.get('TaskTrackingZone');\n    };\n    TaskTrackingZoneSpec.prototype.getTasksFor = function (type) {\n      switch (type) {\n        case 'microTask':\n          return this.microTasks;\n        case 'macroTask':\n          return this.macroTasks;\n        case 'eventTask':\n          return this.eventTasks;\n      }\n      throw new Error('Unknown task format: ' + type);\n    };\n    TaskTrackingZoneSpec.prototype.onScheduleTask = function (parentZoneDelegate, currentZone, targetZone, task) {\n      task['creationLocation'] = new Error(\"Task '\".concat(task.type, \"' from '\").concat(task.source, \"'.\"));\n      var tasks = this.getTasksFor(task.type);\n      tasks.push(task);\n      return parentZoneDelegate.scheduleTask(targetZone, task);\n    };\n    TaskTrackingZoneSpec.prototype.onCancelTask = function (parentZoneDelegate, currentZone, targetZone, task) {\n      var tasks = this.getTasksFor(task.type);\n      for (var i = 0; i < tasks.length; i++) {\n        if (tasks[i] == task) {\n          tasks.splice(i, 1);\n          break;\n        }\n      }\n      return parentZoneDelegate.cancelTask(targetZone, task);\n    };\n    TaskTrackingZoneSpec.prototype.onInvokeTask = function (parentZoneDelegate, currentZone, targetZone, task, applyThis, applyArgs) {\n      var _a;\n      if (task.type === 'eventTask' || ((_a = task.data) === null || _a === void 0 ? void 0 : _a.isPeriodic)) return parentZoneDelegate.invokeTask(targetZone, task, applyThis, applyArgs);\n      var tasks = this.getTasksFor(task.type);\n      for (var i = 0; i < tasks.length; i++) {\n        if (tasks[i] == task) {\n          tasks.splice(i, 1);\n          break;\n        }\n      }\n      return parentZoneDelegate.invokeTask(targetZone, task, applyThis, applyArgs);\n    };\n    TaskTrackingZoneSpec.prototype.clearEvents = function () {\n      while (this.eventTasks.length) {\n        Zone.current.cancelTask(this.eventTasks[0]);\n      }\n    };\n    return TaskTrackingZoneSpec;\n  }();\n  // Export the class so that new instances can be created with proper\n  // constructor params.\n  Zone['TaskTrackingZoneSpec'] = TaskTrackingZoneSpec;\n});","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}